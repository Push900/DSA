//adt menu in complex operations
#include <stdio.h>
#include <stdlib.h>

//Struct
typedef struct{
    double real;
    double imag;
} Complex;

//Function prototypes
Complex c_add(Complex c1, Complex c2);
Complex c_sub(Complex c1, Complex c2);
Complex c_mul(Complex c1, Complex c2);
Complex c_div(Complex c1, Complex c2);
int complex_equal(Complex a, Complex b);
void complex_display(Complex c);


int main() {
    int choice;
    Complex c1, c2, c3;

    printf("Enter first complex real and imaginary part: ");
    scanf("%lf %lf", &c1.real, &c1.imag);

    printf("Now second complex real and imaginary part: ");
    scanf("%lf %lf", &c2.real, &c2.imag);

//menu
    while (1) {
        printf("\nMENU\n1. Addition\n2. Subtraction\n3. Multiplication\n4. Division\n5. Equality\n6. Exit\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                c3 = c_add(c1, c2);
                printf("Result: ");
                complex_display(c3);
                break;
            case 2:
                c3 = c_sub(c1, c2);
                printf("Result: ");
                complex_display(c3);
                break;
            case 3:
                c3 = c_mul(c1, c2);
                printf("Result: ");
                complex_display(c3);
                break;
            case 4:
                if (c2.real == 0 && c2.imag == 0) {
                    printf("Error: Cannot divide by zero.\n");
                } else {
                    c3 = c_div(c1, c2);
                    printf("Result: ");
                    complex_display(c3);
                }
                break;
            case 5:
                if (complex_equal(c1, c2)) {
                    printf("Yes, they are equal\n");
                } else {
                    printf("No, they are not equal\n");
                }
                break;
            case 6:
                printf("Exiting program.\n");
                return 0;
            default:
                printf("Invalid operation.\n");
                break;
        }
    }

    return 0;
}

// Function definitions
Complex c_add(Complex c1, Complex c2) {
    Complex c3;
    c3.real = c1.real + c2.real;
    c3.imag = c1.imag + c2.imag;
    return c3;
}

Complex c_sub(Complex c1, Complex c2) {
    Complex c3;
    c3.real = c1.real - c2.real;
    c3.imag = c1.imag - c2.imag;
    return c3;
}

Complex c_mul(Complex c1, Complex c2) {
    Complex c3;
    c3.real = (c1.real * c2.real) - (c1.imag * c2.imag);
    c3.imag = (c1.imag * c2.real) + (c2.imag * c1.real);
    return c3;
}

Complex c_div(Complex c1, Complex c2) {
    Complex c3;
    double denom = (c2.real * c2.real) + (c2.imag * c2.imag); // Denominator for division
    if (denom == 0) {
        printf("Error: Cannot divide by zero.\n");
        exit(1);
    }
    c3.real = ((c1.real * c2.real) + (c1.imag * c2.imag)) / denom;
    c3.imag = ((c1.imag * c2.real) - (c1.real * c2.imag)) / denom;
    return c3;
}

void complex_display(Complex c) {
    if (c.imag >= 0) {
        printf("%lf + %lfj\n", c.real, c.imag);
    } else {
        printf("%lf %lfj\n", c.real, c.imag);
    }
}

int complex_equal(Complex c1, Complex c2) {
    return (c1.real == c2.real && c1.imag == c2.imag);
}
